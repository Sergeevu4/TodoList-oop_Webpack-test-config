/*
  ! Контролер
  Ответчает за взаимодействие, управление Модели и Представления,
  так как о друг друге они ничего не знают.

    Необходимо подписаться на обновление представления (view)
    Например у представления есть Форма, и когда что-нибудь происходит
    внутри этой формы, нужно будет сообщить контролеру о том, что пользователь
    ввел что-то в поле и нажал на кнопку добавить.

    Контролеру необходимо сообщить об этом событии, но
    так как Представление ничего не знает о Контролере и Модели,
    ответственность за получения уведомления от представления лежит на Контролере.
    Для этого Контролер подпишется на событие на Представлении.

*/

class Controller {
  constructor(model, view) {
    this.model = model;
    this.view = view;

    // У Представления есть метод для подписки на обновления

    // ! Методы подписи на события в Представлении, отправляем обработчики:

    // # Метод сработает внутри handleAdd через emit('add', value -> title)
    view.on('add', this.addTodo.bind(this));

    // # Метод сработает внутри handelToggle через emit('toggle', { id, completed })
    view.on('toggle', this.toggleTodo.bind(this));

    // # Метод сработает внутри handelEdit emit('edit', { id, title })
    view.on('edit', this.editTodo.bind(this));

    // # Метод сработает внутри handletRemoveemit('remove', { id })
    view.on('remove', this.remove.bind(this));

    // # Метод вывода сохраненых данных в LocalStorage из Модели
    view.show(model.state); // список задач: массив state
  }

  // # Метод по добавлению задачи
  addTodo(title) {
    // title - заголовок Задачи, то что ввел пользователь переданно через Представление(view)
    // Просим у Модели добавить новый объект в хранилище, и после его вернуть.
    const todo = this.model.addItem({
      id: String(Date.now()), // Быстрый способ получить уникальное значение Date.now()
      title, // es6 title, нет необходимости писать title: title
      completed: false,
    });

    /*
      После того как мы добавили объект через Модель,
      далее необходимо добавить этот вновь созданный объект
      в Представление, и на его основе создать новый li элемент
      и добавил в ul через метод addItem у Контролера.
    */

    this.view.addItem(todo);
  }

  // # Метод переключения состояния задачи
  toggleTodo({ id, completed }) {
    // Просим Модель обновить задачу, после получаем ее обратно
    const todo = this.model.updateItem(id, { completed });

    /*
			Находим в Модели объект, изменяет его и
			обратно возвращаем в Состояние измененную версию.
			После обратно передаем измененный объект в Представление
		*/

    this.view.toggleItem(todo);
  }

  // # Метод редактирования задачи
  editTodo({ id, title }) {
    // Просим Модель обновить задачу, после получаем ее обратно
    const todo = this.model.updateItem(id, { title }); // title - что введено в поле задачи.=

    this.view.editItem(todo);
  }

  // # Метод удаления задачи
  remove(id) {
    this.model.removeItem(id);
    this.view.removeItem(id);
  }
}

export default Controller;
