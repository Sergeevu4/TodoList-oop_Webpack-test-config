/*
  ! Состояние:
  Модель ничего не знает о своем представлении, акружении.
  Все, что она знает, только операции которые перечислены в ее методах.

  Состояние: - это массив из этих объектов (todo):
  {
    id: уникальное значение,
    title: '',
    completed: false
  }

	? Мы ни в коем случае не изменяем объект todo.

	Существенными отличия ООП + паттернов проектирования (Model-View-Controller + Publish/subscribe)
	от Процедурного подхода к написанию кода:
		1) Подобную архитектуру проще поддерживать и в дальнейшем развивать.
		2) При использовании Процедурного подхода, не было возможности сохранять данные куда-либо,
		например в локальное хранилище, они все были связанны с HTML, но при использовании ООП
		существует точное понимание, что такое данные и есть простой способ добавить и сохранять данные в локальное хранилище (LocalStorage):
		helper: save + load.


	При этом сама Модель не знает ничего про сохранение этих данных, она информирует о том, что данные
	изменились через отправку событие 'change' EventEmittet

	Событие this.emit('change', this.state)
	срабатывает каждый раз при изменении данных
	Добавление(addItem)
	Обновление(updateItem)
	Удаление(removeItem)
*/

import { EventEmittet } from './helpers.js';

class Model extends EventEmittet {
  // state  - это данные (массив)
  constructor(state = []) {
    super();
    this.state = state;
  }

  // * Метода которые изменяют состояния :

  // # 1. Метод получения данных
  getItem(id) {
    /*
			В момент создания id в методе addTodo в Контролере,
			Date.now - создает тип данных Number, но при получении потом этого id через Dom
			тип данных меняется на String. Можно воспользоваться ==, или же при создания id
			Сразу же преобразовать в String
		*/
    return this.state.find((item) => item.id === id);
  }

  // # 2. Метод добавления данных
  addItem(item) {
    this.state.push(item);
    // Полученный объект из Контролера отправляем обратно
    this.emit('change', this.state); // Сохранение данных в LocalStorage
    return item;
  }

  // # 3. Метод для обновления данных
  updateItem(id, data) {
    const item = this.getItem(id);

    // Перебор свойств объекта data, и запись эти свойств в item
    Object.keys(data).forEach((prop) => (item[prop] = data[prop]));

    this.emit('change', this.state); // Сохранение данных в LocalStorage

    return item;
    /*
			Пример взаимосвязи Представления - Контролера - Модели:
			Представления срабатывает события handelToggle внутри которого вызывается передача события,
			метода emit 'toggle' (EventEmittet) и передается объект { id, completed } в Контролер.
			Внутри контролера этот объект попадает метод toggleTodo, далее внутри этого метода вызывается
			метод model.updateItem и уже внутри этого метода, согласно переданным параметрам, меняет состояние объекта
			todo который храниться в массиве state и находится согласно переданному id.

			После Модель возвращает обратно модифицированный объект в Контролер, он же
			вызывает у Представления последующие методы, аргументом которых является модифицированный объект,
			манипуляции с котором происходят только в Моделе.
		*/
  }

  // # 4. Метод удаления из массива
  removeItem(id) {
    const index = this.state.findIndex((item) => item.id === id);

    if (index > -1) {
      // Если больше чем -1, то элемент есть в массиве
      this.state.splice(index, 1);
      this.emit('change', this.state); // Сохранение данных в LocalStorage
    }
  }
}

export default Model;
